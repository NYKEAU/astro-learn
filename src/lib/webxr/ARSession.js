import * as THREE from "three";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
import { WEBXR_CONFIG, getErrorMessage } from "./config.js";

export class ARSession {
  constructor() {
    this.session = null;
    this.renderer = null;
    this.scene = null;
    this.camera = null;
    this.reticle = null;
    this.model = null;
    this.hitTestSource = null;
    this.hitTestSourceRequested = false;
    this.isPlaced = false;
    this.language = "fr";
  }

  async init(modelURL, language = "fr") {
    this.language = language;
    console.log("üîß Initialisation ARSession...");
    console.log("üìÑ ModelURL:", modelURL);

    try {
      // V√©rifier le support WebXR
      console.log("üîç V√©rification support WebXR...");
      if (!navigator.xr) {
        console.log("‚ùå navigator.xr non disponible");
        throw new Error(getErrorMessage("webxrNotSupported", language));
      }
      console.log("‚úÖ navigator.xr disponible");

      // V√©rifier le support AR
      console.log("üîç V√©rification support AR...");
      const isSupported = await navigator.xr.isSessionSupported("immersive-ar");
      console.log("üìä Support AR:", isSupported);
      if (!isSupported) {
        console.log("‚ùå AR non support√©e");
        throw new Error(getErrorMessage("arNotSupported", language));
      }
      console.log("‚úÖ AR support√©e");

      // NOUVELLE APPROCHE: Demander directement la session WebXR avec permissions
      console.log(
        "üöÄ Demande session AR avec gestion automatique des permissions..."
      );

      // Configuration de session optimis√©e
      let sessionOptions = {
        requiredFeatures: ["hit-test"],
        optionalFeatures: ["dom-overlay", "light-estimation"],
      };

      // Cr√©er un div d√©di√© pour domOverlay si n√©cessaire
      if (sessionOptions.optionalFeatures.includes("dom-overlay")) {
        const overlayRoot = document.createElement("div");
        overlayRoot.id = "ar-overlay-root";
        overlayRoot.style.cssText =
          "position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999;";
        document.body.appendChild(overlayRoot);
        sessionOptions.domOverlay = { root: overlayRoot };
        console.log("üé≠ DOM Overlay configur√©");
      }

      console.log("üîë Options de session:", sessionOptions);

      try {
        // NOUVELLE APPROCHE: Demander explicitement la permission cam√©ra AVANT WebXR
        console.log("üìπ Test et demande permission cam√©ra...");
        try {
          const testStream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment" },
          });
          console.log("‚úÖ Permission cam√©ra accord√©e");
          testStream.getTracks().forEach((track) => track.stop()); // Fermer imm√©diatement
        } catch (permError) {
          console.error("‚ùå Permission cam√©ra refus√©e:", permError.name);
          if (permError.name === "NotAllowedError") {
            throw new Error(
              "‚ùå Veuillez autoriser l'acc√®s √† la cam√©ra pour utiliser l'AR"
            );
          }
          throw permError;
        }

        // Demander la session WebXR (maintenant que la permission cam√©ra est accord√©e)
        this.session = await navigator.xr.requestSession(
          "immersive-ar",
          sessionOptions
        );
        console.log("‚úÖ Session AR cr√©√©e:", this.session);

        // V√©rifications post-session
        console.log("üì± √âtat session AR:", {
          renderState: this.session.renderState,
          inputSources: this.session.inputSources?.length || 0,
          environmentBlendMode: this.session.environmentBlendMode,
          visibilityState: this.session.visibilityState,
        });
      } catch (sessionError) {
        console.error("‚ùå ERREUR demande session AR:", sessionError);
        console.error("üîç Type erreur session:", sessionError.name);
        console.error("üîç Message erreur session:", sessionError.message);

        // Gestion sp√©cifique des erreurs WebXR
        if (sessionError.name === "NotSupportedError") {
          throw new Error(
            "‚ùå Fonctionnalit√© WebXR non support√©e sur cet appareil"
          );
        } else if (sessionError.name === "SecurityError") {
          throw new Error(
            "‚ùå Erreur de s√©curit√© - Assurez-vous d'√™tre en HTTPS"
          );
        } else if (sessionError.name === "NotAllowedError") {
          throw new Error(
            "‚ùå Permission cam√©ra refus√©e - Rechargez et autorisez l'acc√®s"
          );
        } else if (sessionError.name === "InvalidStateError") {
          throw new Error(
            "‚ùå √âtat invalide - Une session AR est peut-√™tre d√©j√† active"
          );
        }
        throw sessionError;
      }

      // Configurer Three.js APR√àS avoir obtenu la session
      await this.setupThreeJS();

      // Charger le mod√®le 3D
      await this.loadModel(modelURL);

      // Configurer les √©v√©nements
      this.setupEventListeners();

      // D√©marrer la boucle de rendu avec monitoring am√©lior√©
      console.log("üîÑ D√©marrage de la boucle de rendu...");
      this._frameCount = 0;
      this._lastFrameTime = performance.now();
      this.renderer.setAnimationLoop(this.render.bind(this));

      // Monitoring des frames WebXR
      this.startFrameMonitoring();

      // V√©rifier le canvas apr√®s initialisation
      this.checkCanvasStatus();

      console.log("ü•Ω Session AR initialis√©e avec succ√®s");
      return this.session;
    } catch (error) {
      console.error("‚ùå Erreur lors de l'initialisation AR:", error);
      console.error("üîç Type erreur:", typeof error);
      console.error("üîç Nom erreur:", error.name);
      console.error("üîç Message erreur:", error.message);
      console.error("üîç Stack erreur:", error.stack);

      // Nettoyer en cas d'erreur
      this.cleanup();
      throw error;
    }
  }

  startFrameMonitoring() {
    // Monitoring initial apr√®s 2 secondes
    setTimeout(() => {
      console.log("üîç √âtat frames WebXR apr√®s 2s:", {
        frameCount: this._frameCount,
        sessionActive: !!this.session,
        sessionVisibility: this.session?.visibilityState,
        rendererXREnabled: this.renderer?.xr?.enabled,
        sessionMode: this.session?.environmentBlendMode,
        fps: this._frameCount > 0 ? Math.round(this._frameCount / 2) : 0,
      });

      if (this._frameCount === 0) {
        console.error("‚ùå PROBL√àME: Aucune frame WebXR apr√®s 2s!");
        console.error("üí° Diagnostics sugg√©r√©s:");
        console.error("   - V√©rifiez que ARCore/ARKit est install√© et activ√©");
        console.error("   - Assurez-vous d'√™tre en HTTPS");
        console.error("   - Red√©marrez l'application cam√©ra et r√©essayez");
        console.error(
          "   - V√©rifiez les permissions cam√©ra dans les param√®tres"
        );
      }
    }, 2000);

    // Monitoring continu toutes les 10 secondes
    this._monitoringInterval = setInterval(() => {
      if (this.session && this._frameCount > 0) {
        const now = performance.now();
        const timeDelta = (now - this._lastFrameTime) / 1000;
        const currentFPS = this._frameCount / timeDelta;

        console.log("üìä Stats AR:", {
          frames: this._frameCount,
          fps: Math.round(currentFPS),
          sessionState: this.session.visibilityState,
          modelPlaced: this.isPlaced,
        });
      }
    }, 10000);
  }

  checkCanvasStatus() {
    setTimeout(() => {
      const canvas = this.renderer?.domElement;
      if (canvas) {
        console.log("üñ•Ô∏è √âtat du canvas:", {
          width: canvas.width,
          height: canvas.height,
          clientWidth: canvas.clientWidth,
          clientHeight: canvas.clientHeight,
          style: canvas.style.cssText,
          parentNode: canvas.parentNode ? "attach√©" : "non attach√©",
          visibility: getComputedStyle(canvas).visibility,
          display: getComputedStyle(canvas).display,
          position: getComputedStyle(canvas).position,
        });

        // Forcer le canvas en plein √©cran si n√©cessaire
        if (canvas.style.position !== "fixed") {
          canvas.style.position = "fixed";
          canvas.style.top = "0";
          canvas.style.left = "0";
          canvas.style.width = "100%";
          canvas.style.height = "100%";
          canvas.style.zIndex = "1000";
          console.log("üì± Canvas forc√© en plein √©cran");
        }
      }
    }, 500);
  }

  async setupThreeJS() {
    console.log("üé® Configuration Three.js pour WebXR...");

    // Cr√©er le renderer WebXR AVANT de configurer la session
    console.log("üñ•Ô∏è Cr√©ation du renderer WebGL...");
    this.renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
      powerPreference: "high-performance",
    });
    console.log("‚úÖ Renderer cr√©√©");

    // Configuration du renderer
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limiter pour les performances
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.outputColorSpace = THREE.SRGBColorSpace;

    console.log(
      "üìê Taille renderer:",
      window.innerWidth,
      "x",
      window.innerHeight
    );

    // IMPORTANT: Activer XR AVANT de lier la session
    this.renderer.xr.enabled = true;
    console.log("ü•Ω XR activ√© sur le renderer");

    // CORRECTION: Lier la session APR√àS avoir activ√© XR
    if (this.session) {
      await this.renderer.xr.setSession(this.session);
      console.log("üîó Session XR li√©e au renderer");

      // CRITIQUE: S'assurer que le reference space est configur√©
      // Tenter diff√©rents types de reference space par ordre de pr√©f√©rence
      const referenceSpaceTypes = [
        "local-floor",
        "local",
        "viewer",
        "bounded-floor",
      ];
      let referenceSpace = null;
      let usedType = null;

      for (const spaceType of referenceSpaceTypes) {
        try {
          console.log(`üîç Test reference space '${spaceType}'...`);
          referenceSpace = await this.session.requestReferenceSpace(spaceType);
          usedType = spaceType;
          console.log(`‚úÖ Reference space '${spaceType}' configur√©`);
          break;
        } catch (error) {
          console.warn(`‚ö†Ô∏è '${spaceType}' non disponible:`, error.message);
        }
      }

      if (referenceSpace) {
        this.renderer.xr.setReferenceSpace(referenceSpace);
        console.log(`üéØ Reference space final: '${usedType}'`);
      } else {
        console.error("‚ùå AUCUN reference space disponible sur cet appareil");
        // Ne pas bloquer - laisser WebXR utiliser ses valeurs par d√©faut
        console.warn("‚ö†Ô∏è Continuer sans reference space explicite...");
      }
    }

    // Cr√©er la sc√®ne
    console.log("üé¨ Cr√©ation de la sc√®ne 3D...");
    this.scene = new THREE.Scene();
    console.log("‚úÖ Sc√®ne cr√©√©e");

    // Cr√©er la cam√©ra
    console.log("üì∑ Cr√©ation de la cam√©ra...");
    const { fov, near, far } = WEBXR_CONFIG.camera;
    this.camera = new THREE.PerspectiveCamera(
      fov,
      window.innerWidth / window.innerHeight,
      near,
      far
    );
    console.log("‚úÖ Cam√©ra cr√©√©e avec FOV:", fov);

    // Cr√©er le r√©ticule
    console.log("üéØ Cr√©ation du r√©ticule...");
    this.createReticle();
    console.log("‚úÖ R√©ticule cr√©√©");

    // Ajouter l'√©clairage
    console.log("üí° Configuration de l'√©clairage...");
    this.setupLighting();
    console.log("‚úÖ √âclairage configur√©");

    // Ajouter le canvas au DOM avec style appropri√©
    console.log("üì± Ajout du canvas au DOM...");
    const canvas = this.renderer.domElement;
    canvas.style.position = "fixed";
    canvas.style.top = "0";
    canvas.style.left = "0";
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    canvas.style.zIndex = "1000";
    document.body.appendChild(canvas);
    console.log("‚úÖ Canvas ajout√© au DOM");
  }

  createReticle() {
    const { innerRadius, outerRadius, segments, color, opacity } =
      WEBXR_CONFIG.reticle;
    const geometry = new THREE.RingGeometry(
      innerRadius,
      outerRadius,
      segments
    ).rotateX(-Math.PI / 2);
    const material = new THREE.MeshBasicMaterial({
      color,
      transparent: true,
      opacity,
    });

    this.reticle = new THREE.Mesh(geometry, material);
    this.reticle.matrixAutoUpdate = false;
    this.reticle.visible = false;
    this.scene.add(this.reticle);
  }

  setupLighting() {
    const { hemisphere, directional } = WEBXR_CONFIG.lighting;

    // √âclairage h√©misph√©rique
    const hemiLight = new THREE.HemisphereLight(
      hemisphere.skyColor,
      hemisphere.groundColor,
      hemisphere.intensity
    );
    this.scene.add(hemiLight);

    // √âclairage directionnel
    const dirLight = new THREE.DirectionalLight(
      directional.color,
      directional.intensity
    );
    dirLight.position.set(...directional.position);
    this.scene.add(dirLight);
  }

  async loadModel(modelURL) {
    console.log("üì¶ Chargement du mod√®le 3D...", modelURL);
    return new Promise((resolve, reject) => {
      const loader = new GLTFLoader();
      console.log("üîß Loader GLTF cr√©√©");

      loader.load(
        modelURL,
        (gltf) => {
          this.model = gltf.scene;

          // Redimensionner le mod√®le pour l'AR avec la configuration
          const box = new THREE.Box3().setFromObject(this.model);
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = WEBXR_CONFIG.model.defaultScale / maxDim;
          this.model.scale.setScalar(scale);

          // Centrer le mod√®le
          const center = box.getCenter(new THREE.Vector3());
          this.model.position.sub(center.multiplyScalar(scale));

          this.model.visible = false;
          this.scene.add(this.model);

          console.log("üì¶ Mod√®le 3D charg√© pour AR");
          resolve(this.model);
        },
        (progress) => {
          console.log(
            "üì• Chargement mod√®le:",
            (progress.loaded / progress.total) * 100 + "%"
          );
        },
        (error) => {
          console.error("‚ùå Erreur chargement mod√®le:", error);
          reject(new Error(getErrorMessage("modelLoadFailed", this.language)));
        }
      );
    });
  }

  setupEventListeners() {
    // G√©rer les taps pour placer le mod√®le
    this.session.addEventListener("select", this.onSelect.bind(this));

    // G√©rer la fin de session
    this.session.addEventListener("end", this.onSessionEnd.bind(this));
  }

  onSelect() {
    if (this.reticle.visible && this.model) {
      // Placer le mod√®le √† la position du r√©ticule
      this.model.position.setFromMatrixPosition(this.reticle.matrix);
      this.model.visible = true;
      this.isPlaced = true;

      console.log("üìç Mod√®le plac√© en AR");
    }
  }

  onSessionEnd() {
    console.log("üîö Fin de session AR d√©tect√©e");
    this.cleanup();
  }

  cleanup() {
    // Arr√™ter le monitoring
    if (this._monitoringInterval) {
      clearInterval(this._monitoringInterval);
      this._monitoringInterval = null;
    }

    // Nettoyer les ressources
    if (
      this.renderer &&
      this.renderer.domElement &&
      this.renderer.domElement.parentNode
    ) {
      this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
    }

    // Nettoyer le DOM overlay si il existe
    const overlayRoot = document.getElementById("ar-overlay-root");
    if (overlayRoot && overlayRoot.parentNode) {
      overlayRoot.parentNode.removeChild(overlayRoot);
      console.log("üßπ DOM Overlay nettoy√©");
    }

    // R√©initialiser les propri√©t√©s
    this.session = null;
    this.renderer = null;
    this.scene = null;
    this.camera = null;
    this.reticle = null;
    this.model = null;
    this.hitTestSource = null;
    this.hitTestSourceRequested = false;
    this.isPlaced = false;
    this._frameCount = 0;
    this._firstFrameLogged = false;
    this._noFrameWarned = false;

    console.log("üîö Nettoyage complet termin√©");
  }

  render(timestamp, frame) {
    try {
      // Compter les frames re√ßues
      if (frame) {
        this._frameCount = (this._frameCount || 0) + 1;

        // Debug premi√®re frame avec plus de d√©tails
        if (!this._firstFrameLogged) {
          console.log("üé¨ PREMI√àRE FRAME WebXR re√ßue:", {
            timestamp,
            frameNumber: this._frameCount,
            session: !!this.session,
            sessionEnvBlendMode: this.session?.environmentBlendMode,
            sessionVisibility: this.session?.visibilityState,
            viewerPose: !!frame.getViewerPose,
            referenceSpace: !!this.renderer.xr.getReferenceSpace(),
          });
          this._firstFrameLogged = true;
        }

        // Log p√©riodique des frames (moins fr√©quent)
        if (this._frameCount % 120 === 0) {
          console.log(
            `üìä Frame WebXR #${this._frameCount} - AR actif (${Math.round(
              (this._frameCount / (performance.now() - this._lastFrameTime)) *
                1000
            )}fps)`
          );
        }

        // V√©rifier que la session est toujours active
        if (this.session?.visibilityState !== "visible") {
          console.warn(
            "‚ö†Ô∏è Session AR non visible:",
            this.session?.visibilityState
          );
        }

        // G√©rer le hit testing pour le r√©ticule
        this.handleHitTest(frame);
      } else {
        // Pas de frame WebXR - probl√®me critique !
        if (!this._noFrameWarned) {
          console.error("‚ùå CRITIQUE: Aucune frame WebXR re√ßue!");
          console.error("üîç Debug session:", {
            sessionExists: !!this.session,
            sessionState: this.session?.visibilityState,
            sessionInputSources: this.session?.inputSources?.length || 0,
            rendererXR: this.renderer?.xr?.enabled,
            environmentBlendMode: this.session?.environmentBlendMode,
            referenceSpace: !!this.renderer?.xr?.getReferenceSpace(),
          });
          this._noFrameWarned = true;
        }
        return; // Ne pas tenter de rendre sans frame
      }

      // Faire tourner le mod√®le s'il est plac√©
      if (this.model && this.model.visible) {
        this.model.rotation.y += WEBXR_CONFIG.model.rotationSpeed;
      }

      // Rendre la sc√®ne seulement si on a une frame valide
      if (frame && this.renderer && this.scene && this.camera) {
        this.renderer.render(this.scene, this.camera);
      }
    } catch (renderError) {
      console.error("‚ùå Erreur dans la boucle de rendu:", renderError);
      console.error("üîç Context:", {
        hasFrame: !!frame,
        hasRenderer: !!this.renderer,
        hasScene: !!this.scene,
        hasCamera: !!this.camera,
        sessionActive: !!this.session,
      });
    }
  }

  async handleHitTest(frame) {
    const referenceSpace = this.renderer.xr.getReferenceSpace();
    const session = this.renderer.xr.getSession();

    // V√©rifier que nous avons bien un reference space
    if (!referenceSpace) {
      console.warn("‚ö†Ô∏è Pas de reference space pour hit test");
      return;
    }

    if (!this.hitTestSourceRequested) {
      try {
        // Essayer d'obtenir la source de hit test depuis les contr√¥leurs
        const inputSources = session.inputSources;
        if (inputSources.length > 0 && inputSources[0].targetRaySpace) {
          this.hitTestSource = await session.requestHitTestSource({
            space: inputSources[0].targetRaySpace,
          });
          console.log("‚úÖ Hit test source cr√©√© depuis input source");
        } else {
          // Fallback : utiliser l'espace de r√©f√©rence du viewer
          this.hitTestSource = await session.requestHitTestSource({
            space: session.viewerSpace || referenceSpace,
          });
          console.log("‚úÖ Hit test source cr√©√© depuis viewer space");
        }
        this.hitTestSourceRequested = true;
      } catch (error) {
        console.warn("‚ö†Ô∏è Hit test source non disponible:", error);
        this.hitTestSourceRequested = true; // √âviter de r√©essayer en boucle
      }
    }

    if (this.hitTestSource) {
      const hitTestResults = frame.getHitTestResults(this.hitTestSource);

      if (hitTestResults.length > 0) {
        const hit = hitTestResults[0];
        this.reticle.visible = true;
        this.reticle.matrix.fromArray(
          hit.getPose(referenceSpace).transform.matrix
        );
      } else {
        this.reticle.visible = false;
      }
    }
  }

  end() {
    if (this.session) {
      this.session.end();
    }
  }
}
